"""
Usage example:
1) For latest run:
    $ rally task export --type junit-xml-single-testsuite --to output.xml

2) For specific run:
    $ rally task export --uuid fake-uuid \
        --type junit-xml-single-testsuite --to output.xml
"""

import datetime as dt
import itertools
import os
import xml.etree.ElementTree as ET

from rally.common import utils
from rally.common import version
from rally import consts
from rally import exceptions
from rally.task import exporter

# NOTE(vponomar): this module is modified version
# of 'rally.plugins.common.exporters.junit' module. Required for compatibility
# with existing test results reporting approach.
# Main difference is in absence of 'testsuites' root element.


@exporter.configure("junit-xml-single-testsuite")
class JUnitXMLSingleTestSuiteExporter(exporter.TaskExporter):
    """Generates task report in JUnit-XML format for one single testsuite.

    An example of the 'junit-xml-single-testsuite' report:
    .. code-block:: xml
        <testsuite id="fake-task-uuid"
                   errors="0"
                   failures="1"
                   skipped="0"
                   tests="2"
                   time="75.0"
                   timestamp="2017-06-04T05:14:00">
          <!--Report is generated by Rally 0.11.2 at 2017-06-04T05:14:00-->
          <testcase classname="Heketi"
                    name="volume_list"
                    id="test-case-uuid"
                    time="29.9695231915"
                    timestamp="2017-06-04T05:14:44" />
          <testcase classname="Heketi"
                    name="volume_list"
                    id="test-case-2-uuid"
                    time="5"
                    timestamp="2017-06-04T05:15:15">
            <failure>fake failure info</failure>
          </testcase>
        </testsuite>
    """

    def generate(self):
        if len(self.tasks_results) != 1:
            raise exceptions.RallyException(
                "Only one test suite is expected to be exported.")

        t = self.tasks_results[0]
        created_at = dt.datetime.strptime(t["created_at"], "%Y-%m-%dT%H:%M:%S")
        updated_at = dt.datetime.strptime(t["updated_at"], "%Y-%m-%dT%H:%M:%S")
        task = {
            "id": t["uuid"],
            "tests": 0,
            "errors": "0",
            "skipped": "0",
            "failures": 0,
            "time": "%.2f" % (updated_at - created_at).total_seconds(),
            "timestamp": t["created_at"],
        }
        test_cases = []
        for workload in itertools.chain(
                *[s["workloads"] for s in t["subtasks"]]):
            class_name, name = workload["name"].split(".", 1)
            test_case = {
                "id": workload["uuid"],
                "time": "%.2f" % workload["full_duration"],
                "name": name,
                "classname": class_name,
                "timestamp": workload["created_at"]
            }
            if not workload["pass_sla"]:
                task["failures"] += 1
                test_case["failure"] = "\n".join(
                    [s["detail"] for s in workload["sla_results"]["sla"]
                     if not s["success"]])
            test_cases.append(test_case)

        task["tests"] = str(len(test_cases))
        task["failures"] = str(task["failures"])

        testsuite = ET.Element("testsuite", task)
        testsuite.append(ET.Comment("Report is generated by Rally %s at %s" % (
            version.version_string(),
            dt.datetime.utcnow().strftime(consts.TimeFormat.ISO8601))))
        for test_case in test_cases:
            failure = test_case.pop("failure", None)
            test_case = ET.SubElement(testsuite, "testcase", test_case)
            if failure:
                ET.SubElement(test_case, "failure").text = failure

        utils.prettify_xml(testsuite)
        raw_report = ET.tostring(testsuite, encoding="utf-8").decode("utf-8")

        if self.output_destination:
            return {
                "files": {self.output_destination: raw_report},
                "open": "file://" + os.path.abspath(self.output_destination),
            }
        else:
            return {"print": raw_report}
